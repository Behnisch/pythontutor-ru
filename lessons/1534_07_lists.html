{% section "Списки" %}
<p>Большинство программ работает не с отдельными переменными, а с набором переменных.
Например, программа может обрабатывать информацию об учащихся класса, считывая список
учащихся с клавиатуры или из файла, при этом изменение количества учащихся в классе
не должно требовать модификации исходного кода программы.

<p>Раньше мы сталкивались с задачей обработки элементов последовательности,
например, вычисляя наибольший элемент последовательности. Но при этом 
мы не сохраняли всю последовательность в памяти компьютера. Однако, 
во многих задачах нужно именно сохранять всю последовательность, например,
если бы нам требовалось вывести все элементы последовательности
в возрастающем порядке (&ldquo;отсортировать последовательность&rdquo;).


<p>Для хранения таких данных можно использовать структуру данных,
называемую в Питоне <u>список</u> (в большинстве же языков
программирования используется другой термин &ldquo;массив&rdquo;).
Список представляет собой последовательность элементов, пронумерованных
от 0, как символы в строке. Список можно задать перечислением элементов
списка в квадратных скобках, например, список можно задать так:

{% program %}
Primes = [2, 3, 5, 7, 11, 13]
Rainbow = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']
{% endprogram %}

<p>В списке <code>Primes</code>&nbsp;&mdash; 6 элементов, а именно:
<code>Primes[0]&nbsp;==&nbsp;2</code>, 

<code>Primes[1]&nbsp;==&nbsp;3</code>, 
<code>Primes[2]&nbsp;==&nbsp;5</code>, 
<code>Primes[3]&nbsp;==&nbsp;7</code>, 
<code>Primes[4]&nbsp;==&nbsp;11</code>, 
<code>Primes[5]&nbsp;==&nbsp;13</code>.
Список <code>Rainbow</code> состоит из 7 элементов, каждый из которых
является строкой.

{% smartsnippet %}
Также как и символы в строке, элементы списка можно индексировать отрицательными
числами с конца, например, 
<code>Primes[-1]&nbsp;==&nbsp;13</code>, 
<code>Primes[-6]&nbsp;==&nbsp;2</code>. 
{% endsmartsnippet %}

<p>Длину списка, то есть количество элементов в нем, можно узнать при помощи функции
<code>len</code>, например, <code>len(Primes)&nbsp;==&nbsp;6</code>.

<p>В отличие от строк, элементы списка можно изменять, присваивая им новые значения.

{% program %}
Rainbow = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']
print(Rainbow[0])
Rainbow[0] = 'красный'
print('Выведем радугу')
for i in range(len(Rainbow)):
    print(Rainbow[i])
{% endprogram %}    

<p>Рассмотрим несколько способов создания и считывания списков. Прежде всего, можно создать
пустой список (не содержащий элементов, длины 0), а в конец списка можно добавлять элементы
при помощи метода <code>append</code>. Например, пусть программа получает на вход
количество элементов в списке <code>n</code>, а потом <code>n</code> элементов
списка по одному в отдельной строке. Вот пример входных данных в таком формате:

{% noprogram %}
5
1809
1854
1860
1891
1925
{% endnoprogram %}

 В этом случае организовать считывание списка можно так:

{% program %}
a = []  # заводим пустой список
n = int(input())  # считываем количество элемент в списке
for i in range(n):  
    new_element = int(input())  # считываем очередной элемент
    a.append(new_element)  # добавляем его в список
    # последние две строки можно было заменить одной:
    # a.append(int(input()))
print(a)
{% inputdata %}
5
1809
1854
1860
1891
1925
{% endinputdata %}
{% endprogram %}

<p>В этом примере создается пустой список, далее считывается количество элементов
в списке, затем по одному считываются элементы списка и добавляются в его конец.
То же самое можно записать, сэкономив переменную <code>n</code>:
{% program %}
a = []
for i in range(int(input())):
    a.append(int(input()))
print(a)
{% inputdata %}
5
1809
1854
1860
1891
1925
{% endinputdata %}
{% endprogram %}


<p>Для списков целиком определены следующие операции: конкатенация списков
(сложение списков, т.&nbsp;е. приписывание к одному списку другого) и повторение списков (умножение списка
на число). Например:

{% program %}
a = [1, 2, 3]
b = [4, 5]
c = a + b
d = b * 3
print([7, 8] + [9])
print([0, 1] * 3)
{% endprogram %}

<p>В результате список <code>c</code> будет равен <code>[1, 2, 3, 4, 5]</code>, а список
<code>d</code> будет равен <code>[4, 5, 4, 5, 4, 5]</code>. Это позволяет по-другому
организовать процесс считывания списков: сначала считать размер списка и создать список
из нужного числа элементов, затем организовать цикл по переменной <code>i</code> начиная
с числа 0 и внутри цикла считывается <code>i</code>-й элемент списка:


{% program %}
a = [0] * int(input())
for i in range(len(a)):
    a[i] = int(input())
{% inputdata %}
5
1809
1854
1860
1891
1925
{% endinputdata %}    
{% endprogram %}

<p>Вывести элементы списка <code>a</code> можно одной инструкцией <code>print(a)</code>,
при этом будут выведены квадратные скобки вокруг элементов списка и запятые между
элементами списка. Такой вывод неудобен, чаще требуется просто вывести все элементы
списка в одну строку или по одному элементу в строке. Приведем два примера, также
отличающиеся организацией цикла:

{% program %}
a = [1, 2, 3, 4, 5]
for i in range(len(a)):
    print(a[i])
{% endprogram %}

<p>Здесь в цикле меняется индекс элемента <code>i</code>, затем выводится элемент
списка с индексом <code>i</code>.


{% program %}
a = [1, 2, 3, 4, 5]
for elem in a:
    print(elem, end=' ')
{% endprogram %}

<p>В этом примере элементы списка выводятся в одну строку, разделенные пробелом,
при этом в цикле меняется не индекс элемента списка, а само значение переменной
(например, в цикле <code>for elem in ['red', 'green', 'blue']</code> переменная
<code>elem</code> будет последовательно принимать значения <code>'red'</code>,
<code>'green'</code>, <code>'blue'</code>.

{% smartsnippet %}
Обратите особое внимание на последний пример! Очень важная часть идеологии Питона&nbsp;&mdash;
это цикл <code>for</code>, который предоставляет удобный способ перебрать все элементы некоторой последовательности.
В этом отличие Питона от Паскаля, где вам обязательно надо перебирать именно <i>индексы</i> элементов,
а не сами элементы. 

<p>Последовательностями в Питоне являются строки, списки, значения функции range() (это не списки), и ещё 
    кое-какие другие объекты.

<p>Приведем пример, демонстрирующий использование цикла <code>for</code> в ситуации, когда из строки
    надо выбрать все цифры и сложить их в массив как числа.
{% program %}
# дано: s = 'ab12c59p7dq'
# надо: извлечь цифры в список digits,
# чтобы стало так:
# digits == [1, 2, 5, 9, 7]

s = 'ab12c59p7dq'
digits = []
for symbol in s:
    if '1234567890'.find(symbol) != -1:
        digits.append(int(symbol))
print(digits)
{% endprogram %}
{% endsmartsnippet %}
{% endsection %}

{% section "Методы split и join" %}
<p>Элементы списка могут вводиться по одному в строке, в этом случае строку целиком можно
считать функцией <code>input()</code>. После этого можно использовать метод строки
<code>split()</code>, возвращающий список строк, которые получатся, если исходную строку разрезать
на части по пробелам. Пример:

{% program %}
# на вход подаётся строка
# 1 2 3
s = input()  # s == '1 2 3'
a = s.split()  # a == ['1', '2', '3']
{% inputdata %}
1 2 3
{% endinputdata %}
{% endprogram %}

<p>Если при запуске этой программы ввести строку <code>1 2 3</code>, то список
<code>a</code> будет равен <code>['1', '2', '3']</code>. Обратите внимание, что
список будет состоять из строк, а не из чисел. Если хочется получить список
именно из чисел, то можно затем элементы списка по одному преобразовать в числа:

{% program %}
a = input().split()
for i in range(len(a)):
    a[i] = int(a[i])
{% inputdata %}
1 2 3
{% endinputdata %}    
{% endprogram %}

<p>Используя специальную магию Питона &mdash; генераторы &mdash;
то же самое можно сделать в одну строку:
{% program %}
a = [int(s) for s in input().split()]
{% inputdata %}
1 2 3
{% endinputdata %}    
{% endprogram %}

<p>Объяснение того, как работает этот код, будет дано в следующем разделе.
Если нужно считать список действительных чисел, то нужно заменить тип
<code>int</code> на тип <code>float</code>.

<p>У метода <code>split()</code> есть необязательный параметр, который
определяет, какая строка будет использоваться в качестве разделителя
между элементами списка. Например, вызов метода <code>split('.')</code>
вернет список, полученный разрезанием исходной строки по символам
<code>'.'</code>:

{% program %}
a = '192.168.0.1'.split('.')
{% endprogram %}


<p>В Питоне можно вывести список строк при помощи однострочной команды. 
    Для этого используется метод строки <code>join</code>. У этого метода один параметр: список строк. 
    В результате возвращается строка, полученная соединением элементов переданного списка 
в одну строку, при этом между элементами списка вставляется
разделитель, равный той строке, к которой применяется метод. Мы знаем, что вы не
поняли предыдущее предложение с первого раза. Поэтому смотрите примеры:
{% program %}
a = ['red', 'green', 'blue']
print(' '.join(a))
# вернёт red green blue
print(''.join(a))
# вернёт redgreenblue
print('***'.join(a))
# вернёт red***green***blue
{% endprogram %}

<p>Если же список состоит из чисел, то придется использовать еще тёмную магию генераторов.
    Вывести элементы списка чисел, разделяя их пробелами, можно так:

{% program %}
a = [1, 2, 3]
print(' '.join([str(i) for i in a]))
# следующая строка, к сожалению, вызывает ошибку:
print(' '.join(a))
{% endprogram %}

<p>Впрочем, если вы не любитель тёмной магии, то вы можете достичь того же эффекта, используя цикл <code>for</code>.
{% endsection %}

{% section "Генераторы списков" %}
<p>Для создания списка, заполненного одинаковыми элементами, можно использовать
оператор повторения списка, например:

{% program %}
n = 5
a = [0] * n
{% endprogram %}

<p>Для создания списков, заполненных по более сложным формулам можно использовать
<em>генераторы</em>: выражения, позволяющие заполнить список некоторой формулой.
Общий вид генератора следующий:


{% noprogram %}
[выражение for переменная in последовательность]
{% endnoprogram %}

<p>где <code><em>переменная</em></code>&nbsp;&mdash; идентификатор некоторой
переменной, <code><em>последовательность</em></code>&nbsp;&mdash; последовательность значений,
который принимает данная переменная (это может быть список, строка или объект, полученный при помощи функции <code>range</code>),
<code><em>выражение</em></code>&nbsp;&mdash; некоторое выражение, как правило, зависящее от использованной в генераторе переменной,
 которым будут заполнены элементы списка.

<p>Вот несколько примеров использования генераторов.

<p>Создать список, состоящий из <code>n</code> нулей можно и при помощи генератора:

{% program %}
a = [0 for i in range(5)]
{% endprogram %}

<p>Создать список, заполненный квадратами целых чисел можно так:

{% program %}
n = 5
a = [i ** 2 for i in range(n)]
{% endprogram %}

<p>Если нужно заполнить список квадратами чисел от 1 до <code>n</code>,
то можно изменить параметры функции <code>range</code> на
<code>range(1, n + 1)</code>:

{% program %}
n = 5
a = [i ** 2 for i in range(1, n + 1)]
{% endprogram %}

<p>Вот так можно получить список, заполненный случайными
числами от 1 до 9 (используя функцию <code>randrange</code>
из модуля <code>random</code>):

{% program %}
n = 10
a = [randrange(1, 10) for i in range(n)]
{% endprogram %}

<p>А в этом примере список будет состоять из строк, считанных
со стандартного ввода: сначала нужно ввести число элементов
списка (это значение будет использовано в качестве аргумента
функции <code>range</code>), потом&nbsp;&mdash; заданное количество строк:

{% program %}
a = [input() for i in range(int(input()))]
{% inputdata %}
5
a
b
1
2
3
{% endinputdata %}
{% endprogram %}
{% endsection %}

{% comment %}
{% section "Срезы" %}
<p>Со списками, так же как и со строками, можно делать срезы. А именно:


<p><code>A[i:j]</code>&nbsp; срез из <code>j-i</code> элементов
<code>A[i]</code>, <code>A[i+1]</code>, ..., <code>A[j-1]</code>.

<p><code>A[i:j:-1]</code>&nbsp; срез из <code>i-j</code> элементов

<code>A[i]</code>, <code>A[i-1]</code>, ..., <code>A[j+1]</code>
(то есть меняется порядок элементов).

<p><code>A[i:j:k]</code>&nbsp; срез с шагом <code>k</code>:
<code>A[i]</code>, <code>A[i+k]</code>, <code>A[i+2*k]</code>,... .
Если значение <code>k</code>&lt;0, то элементы идут в противоположном порядке.



<p>Каждое из чисел <code>i</code> или <code>j</code> может отсутствовать,
что означает &ldquo;начало строки&rdquo; или &ldquo;конец строки&rdquo;

<p>Списки, в отличии от строк, являются <b>изменяемыми объектами</b>:
можно отдельному элементу списка присвоить новое значение. Но можно менять и целиком
срезы. Например:

{% program %}

A = [1, 2, 3, 4, 5]
A[2:4] = [7, 8, 9]
{% endprogram %}

<p>Получится список, у которого вместо двух элементов среза <code>A[2:4]</code>
вставлен новый список уже из трех элементов. Теперь список стал равен
<code>[1, 2, 3, 7, 8, 9, 5]</code>.

{% program %}
A = [1, 2, 3, 4, 5, 6,  7]
A[::-2] = [10, 20, 30, 40]
{% endprogram %}

<p>Получится список <code>[40, 2, 30, 4, 20, 6, 10]</code>. Здесь
<code>A[::-2]</code>&nbsp;&mdash; это список из элементов

<code>A[-1]</code>, <code>A[-3]</code>, <code>A[-5]</code>, A<code>-7</code>,
которым присваиваются значения 10, 20, 30, 40 соответственно. 

<p>Если не непрерывному срезу (то есть срезу  с шагом <code>k</code>, отличному
от 1), присвоить новое значение, то количество элементов в старом и новом срезе
обязательно должно совпадать, в противном случае произойдет ошибка <code>ValueError</code>.

<p>Обратите внимание, <code>A[i]</code>&nbsp;&mdash; это элемент списка, а не срез!



<h2>Операции со списками</h2>
<p>Со списками можно легко делать много разных операций.

<table>
<tr>
<td>x in A</td>
<td>Проверить, содержится ли элемент в списке. Возвращает True или False</td>
</tr>
<tr>
<td>x not in A</td>
<td>То же самое, что not(x in A)</td>
</tr>
<tr>

<td>min(A)</td>
<td>Наименьший элемент списка</td>
</tr>
<tr>
<td>max(A)</td>
<td>Наибольший элемент списка</td>
</tr>
<tr>
<td>A.index(x)</td>
<td>Индекс первого вхождения элемента x в список, при его отсутствии генерирует исключение ValueError</td>
</tr>

<tr>
<td>A.count(x)</td>
<td>Количество вхождений элемента x в список</td>
</tr>
</table>
{% endsection %}
{% endcomment %}
