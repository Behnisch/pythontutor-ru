{% section "Строки" %}
<p>Строка считывается со стандартного ввода функцией <code>input()</code>. Напомним,
что для двух строк определа операция сложения (конкатенации), также определена
операция умножения строки на число.
 
<p>Строка состоит из последовательности символов. Узнать количество символов (длину строки)
можно при помощи функции <code>len</code>. 

<p>Любой другой объект в Питоне можно перевести к строке, которая ему соответствуюет. 
Для этого нужно вызвать функцию <code>str()</code>, передав ей в качестве параметра объект,
переводимый в строку. 

{% smartsnippet %}
На самом деле каждая строка, с точки зрения Питона, &mdash; это объект
класса str. Чтобы получить по объекту другой объект другого класса, как-то ему соответствующий,
можно использовать функцию приведения. Имя этой функции совпадает с именем класса, к которому мы приводим объект.
(Для знатоков: эта функция &mdash; это конструктор объектов данного класса.) Пример: int &mdash; класс
для целых чисел. Перевод строки в число осуществляется функцией <code>int()</code>.
{% endsmartsnippet %}

{% program %}
s = input()
print(len(s))
t = input()
number = int(t)
u = str(number)
print(s * 3)
print(s + ' ' + u)
{% inputdata %}
What is the answer?
42
{% endinputdata %}
{% endprogram %}
{% endsection %}

{% section "Срезы (slices)" %}
<p>Срез (slice)&nbsp;&mdash; извлечение из данной строки одного символа или некоторого фрагмента 
подстроки или подпоследовательности.
 
<p>Есть три формы срезов. Самая простая форма среза: взятие одного символа
строки, а именно, <code>S[i]</code>&nbsp;&mdash; это срез, состоящий из одного символа,
который имеет номер <code>i</code>. При этом считается, что нумерация начинается
с числа 0. То есть если <code><nobr>S = 'Hello'</nobr></code>, то
<code><nobr>S[0] == 'H'</nobr></code>, <code><nobr>S[1] == 'e'</nobr></code>, <code><nobr>S[2] == 'l'</nobr></code>,
<code><nobr>S[3] == 'l'</nobr></code>, <code><nobr>S[4] == 'o'</nobr></code>.

{% smartsnippet %}
Заметим, что в Питоне нет отдельного типа для символов строки. Каждый объект, который получается
в результате среза <code>S[i]</code>&nbsp;&mdash; это тоже строка типа str.
{% endsmartsnippet %}
 
<p>Номера символов в строке (а также в других структурах данных: списках, кортежах)
называются <em>индексом</em>.
 
<p>Если указать отрицательное значение индекса, то номер будет отсчитываться
с конца, начиная с номера <code>-1</code>. То есть <code><nobr>S[-1] == 'o'</nobr></code>,
<code><nobr>S[-2] == 'l'</nobr></code>, <code><nobr>S[-3] == 'l'</nobr></code>, <code><nobr>S[-4] == 'e'</nobr></code>,
<code><nobr>S[-5] == 'H'</nobr></code>. 
 
<p>Или в виде таблицы:
 
<table border='1' cellspacing="0" cellpadding="3"> 
<tr> 
<td>Строка S</td> 
<td align="center">H</td> 
<td align="center">e</td> 
<td align="center">l</td> 
<td align="center">l</td> 
<td align="center">o</td> 
</tr> 
<tr> 
<td>Индекс</td> 
<td align="center">S[0]</td> 
<td align="center">S[1]</td> 
<td align="center">S[2]</td> 
<td align="center">S[3]</td> 
<td align="center">S[4]</td> 
</tr> 
<tr> 
<td>Индекс</td> 
<td align="center">S[-5]</td> 
<td align="center">S[-4]</td> 
<td align="center">S[-3]</td> 
<td align="center">S[-2]</td> 
<td align="center">S[-1]</td> 
</tr> 
</table> 
 
<p>Если же номер символа в срезе строки <code>S</code> больше либо равен <code>len(S)</code>,
или меньше, чем <code>-len(S)</code>, то при обращении к этому символу строки произойдет
ошибка <code>IndexError: string index out of range</code>.
 
<p>Срез с двумя параметрами: <code>S[a:b]</code> 
возвращает подстроку из <code>b - a</code> символов,
начиная с символа c индексом <code>a</code>,
то есть до символа с индексом </code>b</code>, не включая его.
Например, <code>S[1:4] == 'ell'</code>, то же самое получится
если написать <code>S[-4:-1]</code>. Можно использовать как положительные,
так и отрицательные индексы в одном срезе, например, <code>S[1:-1]</code>&nbsp;&mdash;
это строка без первого и последнего символа (срез начинается с символа с индексом 1 и 
заканчиватеся индексом -1, не включая его).
 
<p>При использовании такой формы среза ошибки <code>IndexError</code> 
никогда не возникает. Например, срез <code>S[1:5]</code> 
вернет строку <code>'ello'</code>, таким же будет результат,
если сделать второй индекс очень большим, например,
<code>S[1:100]</code> (если в строке не более 100 символов).
 
<p>Если опустить второй параметр (но поставить двоеточие),
то срез берется до конца строки. Например, чтобы удалить
из строки первый символ (его индекс равен 0), можно
взять срез <code>S[1:]</code>. Аналогично
если опустить первый параметр, то можно взять срез от начала строки.
То есть удалить из строки последний символ можно при помощи среза
<code>S[:-1]</code>. Срез <code>S[:]</code> совпадает с самой строкой
<code>S</code>.

{% smartsnippet %}
<p>
Любые операции среза со строкой создают новые строки и никогда не меняют исходную строку.
В Питоне строки вообще являются неизменяемыми, их невозможно изменить. Можно
лишь в старую переменную присвоить новую строку.

<p>На самом деле в питоне нет и переменных. Есть лишь имена, которые связаны с какими-нибудь объектами.
Можно сначала связать имя с одним объектом, а потом &mdash; с другим. Можно несколько имён
связать с одним и тем же объектом.</p>
{% endsmartsnippet %}
 
<p>Если задать срез с тремя параметрами <code>S[a:b:d]</code>,
то третий параметр задает шаг, как в случае с функцией
<code>range</code>, то есть будут взяты символы с индексами
<code>a</code>, <nobr><code>a + d</code></nobr>, <nobr><code>a + 2 * d</code></nobr> и т.&nbsp;д.
При задании значения третьего параметра, равному 2, в срез попадет
кажый второй символ, а если взять значение среза, равное
<code>-1</code>, то символы будут идти в обратном порядке. 
Например, можно перевернуть строку срезом <code>S[::-1]</code>.

{% program %}
s = 'abcdefg'
print(s[1])
print(s[-1])
print(s[1:3])
print(s[1:-1])
print(s[:3])
print(s[2:])
print(s[:-1])
print(s[::2])
print(s[1::2])
print(s[::-1])
{% endprogram %}
{% endsection %}

{% smartsnippet %}
Обратите внимание на то, как похож третий параметр среза на третий параметр функции range():
{% program %}
s = 'abcdefghijklm'
print(s[0:10:2])
for i in range(0, 10, 2):
    print(i, s[i])
{% endprogram %}
{% endsmartsnippet %}

{% section "Методы" %}
<p>Метод &mdash; это функция, применяемая к объекту, в данном случае &mdash; к строке.
Метод вызывается в виде <code>Имя_объекта.Имя_метода(параметры)</code>.
Например, <code>S.find(&quot;e&quot;)</code>&nbsp;&mdash; это применение к строке <code>S</code> 
метода <code>find</code> с одним параметром <code>&quot;e&quot;</code>.

{% section "Методы find и rfind" %}
<p>Метод <code>find</code> находит в данной строке (к которой применяется  метод)
данную подстроку (которая передается в качестве параметра).
Функция возвращает индекс первого вхождения искомой подстроки.
Если же подстрока не найдена, то метод возвращает значение -1. 
 
{% program %}
S = 'Hello'
print(S.find('e'))
# вернёт 1
print(S.find('ll'))
# вернёт 2
print(S.find('L'))
# вернёт -1
{% endprogram %}
 
<p>Аналогично, метод <code>rfind</code> возвращает индекс последнего вхождения
данной строки (&ldquo;поиск справа&rdquo;).
 
{% program %}
S = 'Hello'
print(S.find('l'))
# вернёт 2
print(S.rfind('l'))
# вернёт 3
{% endprogram %}
 
<p>Если вызвать метод <code>find</code> с тремя параметрами
<code>S.find(T, a, b)</code>, то поиск будет осуществляться
в срезе <code>S[a:b]</code>. Если указать только два параметра
<code>S.find(T, a)</code>, то поиск будет осуществляться
в срезе <code>S[a:]</code>, то есть начиная с символа с индексом
<code>a</code> и до конца строки. Метод <code>S.find(T, a, b)</code> 
возращает индекс в строке <code>S</code>, а не индекс относительно среза.
{% endsection %}

{% section "Метод replace" %}
<p>Метод <code>replace</code> заменяет все вхождения одной строки на другую. Формат:
<code>S.replace(old, new)</code>&nbsp;&mdash; заменить в строке <code>S</code> 
все вхождения подстроки <code>old</code> на подстроку <code>new</code>. Пример:
 
{% program %}
print('Hello'.replace('l', 'L'))
# вернёт 'HeLLo'
{% endprogram %}
  
<p>Если методу <code>replace</code> задать еще один параметр: <code>S.replace(old, new, count)</code>,
то заменены будут не все вхождения, а только не больше, чем первые <code>count</code> из них.
 
{% program %}
print('Abrakadabra'.replace('a', 'A', 2))
# вернёт 'AbrAkAdabra'
{% endprogram %}
{% endsection %}

{% section "Метод count" %}
<p>Подсчитывает количество вхождений одной строки в другую строку. Простейшая
форма вызова <code>S.count(T)</code>&nbsp; возвращает число вхождений строки
<code>T</code> внутри строки <code>S</code>. При этом подсчитываются только
непересекающиеся вхождения, например:
 
{% program %}
print('Abracadabra'.count('a'))
# вернёт 4
print(('a' * 10).count('aa'))
# вернёт 5
{% endprogram %}
 
 
<p>При указании трех параметров <code><nobr>S.count(T, a, b)</nobr></code>,
будет выполнен подсчет числа вхождений строки <code>T</code> 
в срезе <code>S[a:b]</code>.
{% endsection %}

{% endsection %}
