{% section "Очередь" %}
<p>Вспомним карточную игру &laquo;Пьяница&raquo;. Играют двое, у каждого исходно по половине колоды карт.
За один ход двое вскрывают по верхней карте из своих стопок. Чья карта старше, тот забирает две вскрытые карты и кладёт под низ своей стопки.

<p>Будем считать, что про любые две карты в колоде можно сказать, какая из них старше. Будем обозначать карты натуральными
числами, и пусть большее число бьёт меньшее. Колоду будем представлять списком. Для простоты рассмотрим случай шести карт в колоде:

{% noprogram %}
first_hand = [4, 1, 3]
second_hand = [2, 6, 5]
# порядок карт:
# [верхняя карта, середина ... середина, нижняя карта]
{% endnoprogram %}

Тогда после первого хода стопки игроков станут такими:
{% noprogram %}
first_hand = [1, 3, 4, 2]
second_hand = [6, 5]
{% endnoprogram %}

<p>Для моделирования этой ситуации полезно стопку каждого игрока представлять структурой данных &laquo;очередь&raquo;.
Сформулируем требования к очереди.
<ul>
<li>Очередь должна хранить упорядоченный набор элементов.
<li>Очередь должна поддерживать операцию <code>push(x)</code>, которая принимает новый элемент и
 добавляет его в конец набора.
<li>Очередь должна поддерживать операцию <code>pop()</code>, которая возвращает первый элемент набора и удаляет его.
</ul>

<p>Очень просто реализовать очередь, использую стандартные операции со списком:
{% program %}
queue = []  # список для хранения элементов

def push(x):
    queue.append(x)

def pop():
    return queue.pop(0)

push(3)
push(5)
print(pop())  # 3
print(pop())  # 5
{% endprogram %}

<p>У такой реализации очереди есть существенный недостаток: время работы операций. Стандартная реализация списков в Питоне
гарантирует, что <code>append()</code> выполняется в среднем за O(1). Но вот операция <code>pop(0)</code> выполняется за O(n), 
где n &mdash; текущий размер очереди. Действительно, при её выполнении все элементы списка сдвинутся в памяти на одну ячейку влево,
т. е. произойдёт n копирований адресов объектов.

{% smartsnippet %}
<b>Упражнение.</b> Мысленно представьте, что будет, если добавлять элементы в начало списка, а удалять &mdash; из конца.
Поймите, что при этом сложность операции <code>push(x)</code> станет O(n).
{% endsmartsnippet %}

<p>Тем не менее, можно предложить реализацию очереди, в которой обе операции будут выполняться за O(1). Для этого немного модифицируем исходное 
решение. Будем хранить индекс <code>head</code> первого элемента очереди. Изначально <code>head = 0</code>. При каждом удалении элемента из 
очереди мы будем просто смещать этот индекс на одну позицию вправо, не производя физического удаления элементов из очереди.

{% program %}
queue = []  # список для хранения элементов
head = 0  # индекс первого реального элемента в очереди

def push(x):
    queue.append(x)

def pop():
    global head  
    # поскольку мы изменяем глобальную переменную,
    # мы должны явно написать, что она глобальная

    head += 1
    return queue[head - 1]

push(3)
push(5)
print(pop())  # 3
print(pop())  # 5
{% endprogram %}

{% smartsnippet %}
Убедитесь, что теперь операция <code>pop()</code> выполняется за O(1). Как можно узнать, сколько реальных элементов содержится в очереди на каком-то шаге?
{% endsmartsnippet %}

{% endsection %}

{% comment %}

Кратчайший пути до вершины
Площадь комнаты в квадратном лабиринте
Игра в числа

{% endcomment %}
