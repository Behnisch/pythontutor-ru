{% section "Синтаксис условной инструкции" %}
<p>Все ранее рассматриваемые программы имели линейную структуру:
все инструкции выполнялись последовательно одна за одной, каждая
записанная инструкция обязательно выполняется.

<p>Допустим мы хотим по данному числу x определить его абсолютную
величину (модуль). 
Программа должна напечатать значение переменной x, если x&gt;0
или же величину -x в противном случае. Линейная структура программы нарушается: в зависимости
от справедливости условия x&gt;0 должна быть выведена одна или другая величина. 
Соответствующий фрагмент программы на Питоне имеет вид:
{% program %}
x = int(input())
if x > 0:
    print(x)
else:
    print(-x)
{% inputdata %}
-273
{% endinputdata %}
{% endprogram %}

<p>В этой программе используется условная инструкция <code>if</code> (если). После слова <code>if</code>
указывается проверяемое условие <code>(x&nbsp;&gt;&nbsp;0)</code>, завершающееся двоеточием.
После этого идет блок (последовательность) инструкций, который будет выполнен,
если условие истинно, в нашем примере это вывод на экран величины <code>x</code>. 
Затем идет слово <code>else</code> (иначе), также завершающееся двоеточием, и блок инструкций, который будет выполнен,
если проверяемое условие неверно, в данном случае будет выведено значение <code>-x</code>.


<p>Итак, условная инструкция в Питоне имеет следующий синтаксис:

<pre>
if <var>Условие</var>:
    <var>Блок инструкций 1</var>
else:
    <var>Блок инструкций 2</var>
</pre>
   <p><var>Блок инструкций 1</var> будет выполнен, если <var>Условие</var> истинно. 
Если <var>Условие</var> ложно, будет выполнен <var>Блок инструкций 2</var>.


<p>В условной инструкции может отсутствовать слово <code>else</code>
и последующий блок. Такая инструкция называется неполным ветвлением. 
Например, если дано число <code>x</code> и мы хотим заменить его на абсолютную величину <code>x</code>,
то это можно сделать следующим образом:
{% program %}
x = int(input())
if x < 0:
    x = -x
print(x)
{% inputdata %}
-273
{% endinputdata %}
{% endprogram %}
</pre>

<p>В этом примере переменной <code>x</code> будет присвоено значение <code>-x</code>, но только
в том случае, когда <code>x&lt;0</code>. А вот инструкция <code>print(x)</code> будет выполнена всегда,
независимо от проверяемого условия.


<p>Для выделения блока инструкций, относящихся к инструкции <code>if</code> или <code>else</code> в 
языке Питон используются отступы. Все инструкции, которые относятся к одному блоку, должны иметь
равную величину отступа, то есть одинаковое число пробелов в начале строки. Рекомендуется
использовать отступ в 4 пробела и не рекомедуется использовать в качестве отступа символ
табуляции.

<p>Это одно из существенных отличий синтаксиса Питона от синтаксиса большинства языков, в которых
блоки выделяются специальными словами, например, <code>нц... кц</code> в Кумире, <code>begin... end</code>
в Паскале или фигурными скобками в Си.
{% endsection %}

{% section "Вложенные условные инструкции" %}
<p>Внутри условных инструкций можно использовать любые инструкции языка Питон,
в том числе и условную инструкцию. Получаем вложенное ветвление&nbsp;&ndash;
после одной развилки в ходе исполнения программы появляется другая развилка. 
При этом вложенные блоки имеют больший размер отступа (например, 8 пробелов).
Покажем это на примере программы, которая по данным ненулевым числам x
и y определяет, в какой из четвертей координатной плоскости находится точка
(x,y):
{% program %}
x = int(input())
y = int(input())
if x > 0:
    if y > 0:               # x > 0, y > 0
        print("Первая четверть")
    else:                   # x > 0, y < 0
        print("Четвертая четверть")
else:
    if y > 0:               # x < 0, y > 0
        print("Вторая четверть")
    else:                   # x < 0, y < 0
        print("Третья четверть")
{% inputdata %}
2
-3
{% endinputdata %}
{% endprogram %}
<p>В этом примере мы использовали <var>комментарии</var>&nbsp;<!-- /@w -->&ndash; текст,
который интерпретатор игнорирует. Комментариями в Питоне является символ <code>#</code> и весь текст после этого символа
до конца строки. 
{% endsection %}

{% section "Операторы сравнения" %}
<p>Как правило, в качестве проверяемого условия используется результат вычисления
одного из следующих операторов сравнения:

 <dl>
<dt><code>&lt;</code><dd>Меньше&nbsp;<!-- /@w -->&mdash; условие верно, если первый операнд меньше второго. 

<br><dt><code>&gt;</code><dd>Больше&nbsp;<!-- /@w -->&mdash; условие верно, если первый операнд больше второго. 
<br><dt><code>&lt;=</code><dd>Меньше или равно. 
<br><dt><code>&gt;=</code><dd>Больше или равно. 
<br><dt><code>==</code><dd>Равенство. Условие верно, если два операнда равны. 
<br><dt><code>!=</code><dd>Неравенство. Условие верно, если два операнда неравны. 
</dl>

   <p>Например, условие <code>(x&nbsp;*&nbsp;x&nbsp;&lt;&nbsp;1000)</code> означает &ldquo;значение <code>x&nbsp;*&nbsp;x</code> меньше 1000&rdquo;,
а условие <code>(2&nbsp;*&nbsp;x&nbsp;!=&nbsp;y)</code> означает &ldquo;удвоенное значение переменной <code>x</code>

не равно значению переменной <code>y</code>&rdquo;.

<p>Операторы сравнения в Питоне можно объединять в цепочки (в отличии от большинства других языков программирования,
где для этого нужно использовать логические связки), например, <nobr><code>a == b == c</code></nobr> или <nobr><code>1 &lt;= x &lt;= 10</code></nobr>.
{% endsection %}

{% section "Тип данных bool" %}
<p>Операторы сравнения возвращают значения специального логического типа <code>bool</code>. Значения логического
типа могут принимать одно из двух значений: <code>True</code> (истина) или <code>False</code> (ложь). Если преобразовать
логическое <code>True</code> к типу <code>int</code>, то получится 1, а преобразование <code>False</code> даст 0.
При обратном преобразовании число 0 преобразуется в <code>False</code>, а любое ненулевое число в <code>True</code>.
При преобразовании <code>str</code> в <code>bool</code> пустая строка преобразовывается в <code>False</code>,
а любая непустая строка в <code>True</code>.


{% section "Логические операторы" %}

<p>Иногда нужно проверить одновременно не одно, а несколько условий. 
Например, проверить, является ли данное число четным можно при помощи
условия <code>(n&nbsp;%&nbsp;2&nbsp;==&nbsp;0)</code>
(остаток от деления <code>n</code> на <code>2</code> равен <code>0</code>),
а если необходимо проверить, что два данных целых числа <code>n</code> и <code>m</code> являются
четными, необходимо проверить справедливость обоих условий: <code>n&nbsp;%&nbsp;2&nbsp;==&nbsp;0</code>

и <code>m&nbsp;%&nbsp;2&nbsp;==&nbsp;0</code>, для чего их необходимо объединить при помощи оператора <code>and</code>
(логическое И): <code>n&nbsp;%&nbsp;2&nbsp;==&nbsp;0&nbsp;and&nbsp;m&nbsp;%&nbsp;2&nbsp;==&nbsp;0</code>.


<p>В Питоне существуют стандартные логические операторы: логическое И, логическое ИЛИ, логическое
отрицание.

   <p><dfn>Логическое И</dfn> является бинарным оператором
(то есть оператором с двумя операндами: левым и правым)
и имеет вид <code>and</code>. 
Оператор <code>and</code> возвращает <code>True</code> тогда и только
тогда, когда оба его операнда имеют значение <code>True</code>. 

<p><dfn>Логическое ИЛИ</dfn> является бинарным оператором и возвращает <code>True</code> тогда и только
тогда, когда хотя бы один операнд равен <code>True</code>. Оператор &ldquo;логическое ИЛИ&rdquo; имеет
вид <code>or</code>. 

   <p><dfn>Логическое НЕ</dfn> (отрицание) является унарным (то есть с одним операндом)
оператором и имеет вид <code>not</code>, за которым
следует единственный операнд. Логическое НЕ возвращает <code>True</code>,
если операнд равен <code>False</code> и наоборот.


<p>Пример. Проверим, что хотя бы одно из чисел a или b оканчивается на 0:

{% program %}
a = int(input())
b = int(input())
if a % 10 == 0 or b % 10 == 0:
    print('YES')
else:
    print('NO')
{% inputdata %}
15
40
{% endinputdata %}
{% endprogram %}

<p>Проверим, что число a&nbsp;&mdash; положительное, а b&nbsp;&mdash; неотрицательное:

<pre>
    if a &gt; 0 and not (b &lt; 0):

</pre>

<p>Или можно вместо <code> not (b&nbsp;&lt;&nbsp;0)</code> записать <code>(b&nbsp;&gt;=&nbsp;0)</code>.
{% endsection %}
{% endsection %}

{% section "Каскадные условные инструкции" %}
<p>Пример программы, определяющий четверть координатной плоскости, можно переписать используя &ldquo;каскадную&ldquo;

последовательность операцией <code>if... elif... else</code>:

{% program %}
x = int(input())
y = int(input())
if x > 0 and y > 0:
    print("Первая четверть")
elif x > 0 and y < 0:
    print("Четвертая четверть")
elif y > 0:
    print("Вторая четверть")
else:
    print("Третья четверть")
{% inputdata %}
-5
7
{% endinputdata %}
{% endprogram %}

<p>В такой конструкции условия <code>if</code>, ..., <code>elif</code> проверяются по очереди, выполняется блок,
соответствующий первому из истинных условий. Если все проверяемые условия ложны, то выполняется блок <code>else</code>,
если он присутствует.
{% endsection %}

<!--
Максимум из двух чисел

Неравенство треугольника: в каком классе проходят?

Взятие модуля: abs. Округление: ceil, floor.
-->
