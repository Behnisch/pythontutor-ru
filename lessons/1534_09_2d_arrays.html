{% section "Обработка и вывод вложенных списков" %}
Часто в задачах приходится хранить прямоугольные таблицы с данными.
Такие таблицы называются матрицами, или двумерными массивами. В языке
программирования Питон таблицу можно представить в виде списка строк,
каждый элемент которого является в свою очередь списком, например, чисел.
Например, приведём программу, в которой создаётся числовая таблицу из двух строк и трех столбцов, с которой производятся различные действия.

{% program %}
a = [[1, 2, 3], [4, 5, 6]]
print(a[0])
print(a[1])
b = a[0]
print(b)
print(a[0][2])
a[0][1] = 7
print(a)
print(b)
b[2] = 9
print(a[0])
print(b)
{% endprogram %}

<p>Здесь первая строка списка <code>a[0]</code> является списком из чисел
<code>[1, 2, 3]</code>. То есть <code>a[0][0] == 1</code>, значение
<code>a[0][1] == 2</code>, <code>a[0][2] == 3</code>,
<code>a[1][0] == 4</code>, <code>a[1][1] == 5</code>,
<code>a[1][2] == 6</code>.

<p>Для обработки и вывода списка, как правило, используют два вложенных
цикла. Первый цикл перебирает номер строки, второй цикл бежит по элементам внутри строки.
Например, вывести двумерный числовой список на экран построчно,
разделяя числа пробелами внутри одной строки, можно так:

{% program %}
a = [[1, 2, 3, 4], [5, 6], [7, 8, 9]]
for i in range(len(a)):
    for j in range(len(a[i])):
        print(a[i][j], end=' ')
    print()
{% endprogram %}

{% smartsnippet %}
<p>Однажды мы уже пытались объяснить, что переменная цикла for в Питоне может перебирать не только диапазон, создаваемый с помощью функции <code>range()</code>, но и вообще перебирать любые элементы любой последовательности. Последовательностями в Питоне являются списки, строки, а также некоторые другие объекты, с которыми мы пока не встречались. Продемонстрируем, как выводить двумерный массив, используя это удобное свойство цикла <code>for</code>:

{% program %}
a = [[1, 2, 3, 4], [5, 6], [7, 8, 9]]
for row in a:
    for elem in row:
        print(elem, end=' ')
    print()
{% endprogram %}
{% endsmartsnippet %}

<p>Естественно, для вывода одной строки можно воспользоваться
методом <code>join()</code>:

{% noprogram %}
for row in a:
    print(' '.join([str(elem) for elem in row]))
{% endnoprogram %}

<p>Используем два вложенных цикла для подсчета суммы всех
чисел в списке:

{% program %}
a = [[1, 2, 3, 4], [5, 6], [7, 8, 9]]
s = 0
for i in range(len(a)):
    for j in range(len(a[i])):
        s += a[i][j]
print(s)
{% endprogram %}

<p>Или то же самое с циклом не по индексу, а по значениям строк:
{% program %}
a = [[1, 2, 3, 4], [5, 6], [7, 8, 9]]
s = 0
for row in a:
    for elem in row:
        s += elem
print(s)
{% endprogram %}
{% endsection %}

{% section "Создание вложенных списков" %}
<p>Пусть даны два числа: количество строк <code>n</code> и количество столбцов
<code>m</code>. Необходимо создать список размером <code>n</code>&times;<code>m</code>, заполненный нулями.

<p>Очевидное решение оказывается неверным:

{% noprogram %}
a = [[0] * m] * n
{% endnoprogram %}

<p>В этом легко убедиться, если присвоить элементу <code>a[0][0]</code>
значение <code>5</code>, а потом вывести значение другого элемента <code>a[1][0]</code>&nbsp;&mdash; оно тоже будет равно 5. Дело в том, что
<code>[0] * m</code> возвращает ccылку на список из <code>m</code> нулей.
Но последующее повторение этого элемента создает список из <code>n</code>
элементов, которые являются ссылкой на один и тот же список (точно
так же, как выполнение операции <code>b&nbsp;=&nbsp;a</code> для списков не создает
новый список), поэтому все строки результирующего списка на самом деле
являются одной и той же строкой.
<p>В визуализаторе обратите внимание на номер id у списков. Если у двух списков id совпадает, то это на самом деле один и тот же список в памяти.

{% program %}
n = 3
m = 4
a = [[0] * m] * n
a[0][0] = 5
print(a[1][0])
{% endprogram %}

<p>Таким образом, двумерный список нельзя создавать при помощи операции
повторения одной строки. Что же делать?

<p>Первый способ: сначала создадим список из <code>n</code> элементов
(для начала просто из <code>n</code> нулей). Затем сделаем каждый
элемент списка ссылкой на другой одномерный список из <code>m</code>
элементов:

{% program %}
n = 3
m = 4
a = [0] * n
for i in range(n):
    a[i] = [0] * m
{% endprogram %}

<p>Другой (но похожий) способ: создать пустой список, потом <code>n</code>
раз добавить в него новый элемент, являющийся списком-строкой:

{% program %}
n = 3
m = 4
a = []
for i in range(n):
    a.append([0] * m)
{% endprogram %}

<p>Но еще проще воспользоваться генератором: создать список из
<code>n</code> элементов, каждый из которых будет списком,
состоящих из <code>m</code> нулей:

{% program %}
n = 3
m = 4
a = [[0] * m for i in range(n)]
{% endprogram %}

<p>В этом случае каждый элемент создается независимо от остальных
(заново конструируется список <code>[0] * m</code> для заполнения очередного
элемента списка), а не копируются ссылки на один и тот же список.
{% endsection %}



{% section "Ввод двумерного массива" %}
<p>Пусть программа получает на вход двумерный массив в виде
<code>n</code> строк, каждая из которых содержит <code>m</code>
чисел, разделенных пробелами. Как их считать? Например, так:

{% program %}
# в первой строке ввода идёт количество строк массива
n = int(input()) 
a = []
for i in range(n):
    a.append([int(j) for j in input().split()])
{% inputdata %}
3
1 2 3 4
5 6
7 8 9
{% endinputdata %}
{% endprogram %}

<P>Или, без использования сложных вложенных вызовов функций:
{% program %}
# в первой строке ввода идёт количество строк массива
n = int(input()) 
a = []
for i in range(n):
    row = input().split()
    for i in range(len(row)):
        row[i] = int(row[i])
    a.append(row)
{% inputdata %}
3
1 2 3 4
5 6
7 8 9
{% endinputdata %}    
{% endprogram %}

<p>Можно сделать то же самое и при помощи генератора:
{% program %}
# в первой строке ввода идёт количество строк массива
n = int(input()) 
a = [[int(j) for j in input().split()] for i in range(n)]
{% inputdata %}
3
1 2 3 4
5 6
7 8 9
{% endinputdata %}    
{% endprogram %}
{% endsection %}

{% section "Пример обработки двумерного массива" %}
<p>Пусть дан квадратный массив из <code>n</code> строк и <code>n</code> столбцов. 
Необходимо элементам, находящимся на главной диагонали, проходящей из левого верхнего угла в правый
нижний (то есть тем элементам <code>a[i][j]</code>, для которых <code>i==j</code>)
присвоить значение <code>1</code>, элементам,
находящимся выше главной диагонали&nbsp;<!-- /@w -->&ndash; значение 0, элементам, находящимся ниже главной диагонали&nbsp;<!-- /@w -->&ndash; значение 2. То есть необходимо получить такой массив
(пример для <code>n==4</code>):

{% noprogram %}     
1 0 0 0
2 1 0 0
2 2 1 0
2 2 2 1
{% endnoprogram %}
   <p>Рассмотрим несколько способов решения этой задачи. Элементы, которые лежат выше главной диагонали&nbsp;&ndash; это элементы
<code>a[i][j]</code>, для которых <code>i&lt;j</code>, а для элементов ниже главной диагонали <code>i&gt;j</code>. Таким образом, мы можем
сравнивать значения <code>i</code> и <code>j</code> и по ним определять значение <code>A[i][j]</code>. Получаем следующий алгоритм:


{% program %}
n = 4
a = [[0] * n for i in range(n)]
for i in range(n):
    for j in range(n):
        if i < j:
            a[i][j] = 0
        elif i > j:
            a[i][j] = 2
        else:
            a[i][j] = 1
for row in a:
    print(' '.join([str(elem) for elem in row]))
{% endprogram %}
   <p>Данный алгоритм плох, поскольку выполняет одну или две инструкции <code>if</code> для обработки каждого элемента. 
Если мы усложним алгоритм, то мы сможем обойтись вообще без условных инструкций.

   <p>Сначала заполним главную диагональ, для чего нам понадобится один цикл:
{% noprogram %}
for i in range(n):
    a[i][i] = 1
{% endnoprogram %}
   <p>Затем заполним значением <code>0</code> все элементы выше главной диагонали, для чего нам понадобится в каждой из строк
с номером <code>i</code> присвоить значение элементам <code>a[i][j]</code> для <code>j</code>=<code>i+1</code>, ..., <code>n-1</code>. Здесь нам
понадобятся вложенные циклы:


{% noprogram %}
for i in range(n):
    for j in range(i + 1, n):
        a[i][j] = 0
{% endnoprogram %}
   <p>Аналогично присваиваем значение <code>2</code> элементам <code>a[i][j]</code> для <code>j</code>=<code>0</code>, ..., <code>i-1</code>:


{% noprogram %}
for i in range(n):
    for j in range(0, i):
        a[i][j] = 2
{% endnoprogram %}

<p>Можно также внешние циклы объединить в один и получить еще одно, более компактное решение:
{% program %}
n = 4
a = [[0] * n for i in range(n)]
for i in range(n):
    for j in range(0, i):
        a[i][j] = 2
    a[i][i] = 1
    for j in range(i + 1, n):
        a[i][j] = 0
for row in a:
    print(' '.join([str(elem) for elem in row]))
{% endprogram %}

<p>А вот такое решение использует операцию повторения списков для построения очередной
строки списка. <code>i</code>-я строка списка состоит из <code>i</code> чисел
<code>2</code>, затем идет одно число <code>1</code>, затем идет <code>n-i-1</code>

число <code>0</code>:

{% program %}
n = 4
a = [0] * n
for i in range(n):
    a[i] = [2] * i + [1] + [0] * (n - i - 1)
for row in a:
    print(' '.join([str(elem) for elem in row]))    
{% endprogram %}

<p>А можно заменить цикл на генератор:

{% program %}
n = 4
a = [0] * n
a = [[2] * i + [1] + [0] * (n - i - 1) for i in range(n)]
for row in a:
    print(' '.join([str(elem) for elem in row]))    
{% endprogram %}
{% endsection %}

{% section "Вложенные генераторы двумерных массивов" %}
<p>Для создания двумерных массивов можно использовать вложенные генераторы, разместив
генератор списка, являющегося строкой, внутри генератора всех строк. Напомним, что сделать список из <code>n</code> строк и <code>m</code> столбцов можно при помощи генератора,
создающего список из <code>n</code> элементов, каждый элемент которого является списком из

<code>m</code> нулей:

{% noprogram %}
[[0] * m for i in range(n)]
{% endnoprogram %}

<p>Но при этом внутренний список также можно создать при помощи, например, такого генератора:
<code>[0 for j in range(m)]</code>. Вложив один генератор в другой, получим вложенные генераторы:

{% noprogram %}
[[0 for j in range(m)] for i in range(n)]
{% endnoprogram %}

<p>Но если число 0 заменить на некоторое выражение, зависящее от <code>i</code>

(номер строки) и <code>j</code> (номер столбца), то можно получить список, заполненный
по некоторой формуле.

<p>Например, пусть нужно задать следующий массив (для удобства добавлены дополнительные пробелы между элементами):

{% noprogram %}
0  0  0  0  0  0
0  1  2  3  4  5
0  2  4  6  8 10
0  3  6  9 12 15
0  4  8 12 16 20
{% endnoprogram %}

<p>В этом массиве <code>n = 5</code> строк, <code>m = 6</code> столбцов, и элемент
в строке <code>i</code> и столбце <code>j</code> вычисляется по формуле:

<code>a[i][j] = i * j</code>.

<p>Для создания такого массива можно использовать генератор:
{% noprogram %}
[[i * j for j in range(m)] for i in range(n)]
{% endnoprogram %}
{% endsection %}
