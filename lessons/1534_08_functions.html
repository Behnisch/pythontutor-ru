{% section "Функции" %}
<p>Напомним, что в математике факториал числа n определяется как <nobr>n! = 1 &sdot; 2  &sdot; ... &sdot; n.</nobr>
Например, <nobr>5! = 1 &sdot; 2 &sdot; 3 &sdot; 4 &sdot; 5 = 120.</nobr>
Ясно, что факториал можно легко посчитать, воспользовавшись циклом for.
Представим, что нам нужно в нашей программе вычислять факториал разных чисел несколько раз (или в разных местах кода).
Конечно, можно написать вычисление факториала один раз, а затем используя Copy-Paste вставить его везде, где это будет нужно.
{% program %}
# вычислим 3!
res = 1
for i in range(1, 4):
    res *= i
print(res)

# вычислим 5!
res = 1
for i in range(1, 6):
    res *= i
print(res)
{% endprogram %}

<p>Однако, если мы ошибёмся один раз в начальном коде, то потом эта ошибка попадёт в код во все места, куда мы скопировали вычисление факториала. Да и вообще, код занимает больше места, чем мог бы. Чтобы избежать повторного написания одной и той же логики, в языках программирования существуют функции.

<p>Функции &mdash; это такие участки кода, которые изолированы от остальный программы и выполняются только тогда, когда вызываются.
Вы уже встречались с функциями sqrt(), len() и print(). Они все обладают общим свойством: они могут принимать параметры (ноль, один или несколько), и они могут возвращать значение (хотя могут и не возвращать). Например, функция sqrt() принимает один параметр и возвращает значение (корень числа). Функция print() принимает переменное число параметров и ничего не возвращает. 

<p>Покажем, как написать функцию factorial(), которая принимает один параметр &mdash; число, и возвращает значение &mdash; факториал этого числа.
{% program %}
def factorial(n):
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res

print(factorial(3))
print(factorial(5))
{% endprogram %}

<p>Дадим несколько объяснений. Во-первых, код функции должен размещаться в начале программы, вернее, до того места, где мы захотим воспользоваться функцией factorial(). Первая строчка этого примера является описанием нашей функции. factorial — идентификатор, то есть имя нашей функции. После идентификатора в круглых скобках идет список параметров, которые получает наша функция. Список состоит из перечисленных через запятую идентификаторов параметров. В нашем случае список состоит из одной величины n. В конце строки ставится двоеточие.

<p>Далее идет тело функции, оформленное в виде блока, то есть с отступом. Внутри функции вычисляется значение факториала числа n и оно сохраняется в переменной res. Функция завершается инструкцией return res, которая завершает работу функции и возвращает значение переменной res. 

<p>Инструкция return может встречаться в произвольном месте функции, ее исполнение завершает работу функции и возвращает указанное значение в место вызова. Если функция не возвращает значения, то инструкция return используется без возвращаемого значения. В функциях, которым не нужно  возвращать значения, инструкция return может отсутствовать.

<p>Приведём ещё один пример. Напишем функцию max(), которая принимает два числа и возвращает максимальное из них (на самом деле, такая функция уже встроена в Питон).

{% program %}
def max(a, b):
    if a > b:
        return a
    else:
        return b

print(max(3, 5))
print(max(5, 3))
print(max(int(input()), int(input())))
{% inputdata %}
10
20
{% endinputdata %}
{% endprogram %}

<p>Теперь можно написать функцию max3(), которая принимает три числа и возвращает максимальное их них.
{% program %}
def max(a, b):
    if a > b:
        return a
    else:
        return b

def max3(a, b, c):
    return max(max(a, b), c)

print(max3(3, 5, 4))
{% endprogram %}

{% smartsnippet %}
Встроенная функция max() в Питоне может принимать переменное число аргументов и возвращать максимум из них. Приведём пример того, как такая функция может быть написана.
{% program %}
def max(*a):
    res = a[0]
    for val in a[1:]:
        if val > res:
            res = val
    return res

print(max(3, 5, 4))
{% endprogram %}
Все переданные в эту функцию параметры соберутся в один список с именем a, на что указывает звёздочка в строке объявления функции.
{% endsmartsnippet %}
{% endsection %}

{% section "Локальные и глобальные переменные" %}
<p>Внутри функции можно использовать переменные, объявленные вне этой функции
 
{% program %}
def f():
    print(a)

a = 1
f()
{% endprogram %}
 
<p>Здесь переменной <code>a</code> присваивается значение 1, и функция <code>f()</code> 
печатает это значение, несмотря на то, что до объявления функции <code>f</code> эта переменная 
не инициализируется. В момент вызова функции <code>f()</code> переменной <code>a</code> 
уже присвоено значение, поэтому функция <code>f()</code> может вывести его на экран.
 
<p>Такие переменные (объявленные вне функции, но доступные внутри функции)
называются <em>глобальными</em>.
 
<p>Но если инициализировать какую-то переменную внутри функции,
использовать эту переменную вне функции не удастся. Например:
 
{% program %}
def f():
    a = 1

f()
print(a)
{% endprogram %}
 
<p>Получим ошибку <code>NameError: name 'a' is not defined</code>. Такие переменные, объявленные внутри функции,
называются <em>локальными</em>. Эти переменные становятся недоступными после выхода из функции.
 
<p>Интересным получится результат, если попробовать изменить значение глобальной переменной внутри функции:
 
{% program %}
def f():
    a = 1
    print(a)

a = 0
f()
print(a)
{% endprogram %}
 
<p>Будут выведены числа 1 и 0. Несмотря на то, что значение переменной <code>a</code> 
изменилось внутри функции, вне функции оно осталось прежним! Это сделано в целях
&ldquo;защиты&rdquo; глобальных переменных от случайного изменения из функции.
Например, если функция будет вызвана из цикла по переменной <code>i</code>, а в этой функции
будет использована переменная <code>i</code> также для организации цикла, то эти переменные должны
быть различными. Если вы не поняли последнее предложение, то посмотрите на следующий код и подумайте, как бы он работал
если бы внутри функции изменялась переменная i.
{% program %}
def factorial(n):
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res

for i in range(1, 6):
    print(i, '! = ', factorial(i), sep='')
{% endprogram %}

Если бы глобальная переменная i изменялась внутри функции, то мы бы получили вот что:
{% noprogram %}
5! = 1
5! = 2
5! = 6
5! = 24
5! = 120
{% endnoprogram %}

Итак, если внутри функции модифицируется значение некоторой переменной,
то переменная с таким именем становится локальной переменной, и ее модификация не приведет
к изменению глобальной переменной с таким же именем.
 
<p>Более формально: интерпретатор Питон считает переменную локальной для данной функции, если в её коде
 есть хотя бы одна инструкция, модифицирующая значение переменной, то эта переменная считается локальной
и не может быть использована до инициализации. Инструкция, модифицирующая значение переменной &mdash; это операторы <code>=</code>, <code>+=</code>, а также использование переменной в качестве параметра цикла <code>for</code>.
При этом даже если инструкция,
модицифицирующая переменную никогда не будет выполнена, интерпретатор это проверить
не может, и переменная все равно считается локальной. Пример:
 
{% program %}
def f():
    print(a)
    if False:
        a = 0

a = 1
f()
{% endprogram %}

<p>Возникает ошибка: <code>UnboundLocalError: local variable 'a' referenced before assignment</code>.
А именно, в функции <code>f()</code> идентификатор <code>a</code> становится локальной переменной,
т.к. в функции есть команда, модифицирующая переменную <code>a</code>, пусть даже никогда и 
не выполняющийся (но интерпретатор не может это отследить). Поэтому вывод переменной <code>a</code> 
приводит к обращению к неинициализированной локальной переменной.
 
<p>Чтобы функция могла изменить значение глобальной переменной, необходимо объявить эту переменную
внутри функции, как глобальную, при помощи ключевого слова <code>global</code>:
 
{% program %}
def f():
    global a
    a = 1
    print(a)

a = 0
f()
print(a)
{% endprogram %}
 
 
<p>В этом примере на экран будет выведено 1 1, так как переменная <code>a</code> объявлена, как глобальная,
и ее изменение внутри функции приводит к тому, что и вне функции переменная
будет доступна.
 
<p>Тем не менее, лучше не изменять значения глобальных переменных внутри функции. Если ваша функция должна поменять
какую-то переменную, пусть лучше она вернёт это значением, и вы сами при вызове функции явно присвоите в переменную это значение.
Если следовать этим правилам, то функции получаются независимыми от кода, и их можно легко копировать из одной программы в другую.
 
<p>Например, пусть ваша программа должна посчитать факториал вводимого числа, который вы потом захотите сохранить в переменной f.
Вот как это <u>не стоит</u> делать:

{% program %}
def factorial(n):
    global f
    res = 1
    for i in range(2, n + 1):
        res *= i
    f = res

n = int(input())
factorial(n)
# дальше всякие действия с переменной f
{% inputdata %}
5
{% endinputdata %}
{% endprogram %}

<p>Этот код написан плохо, потому что его трудно использовать ещё один раз. Если вам завтра понадобится в другой программе использовать функцию &laquo;факториал&raquo;, то вы не сможете просто скопировать эту функцию отсюда и вставить в вашу новую программу. Вам придётся поменять то, как она возвращает посчитанное значение.

<p>Гораздо лучше переписать этот пример так:

{% program %}
# начало куска кода, который можно копировать из программы в программу
def factorial(n):
    res = 1
    for i in range(2, n + 1):
        res *= i
    return res
# конец куска кода

n = int(input())
f = factorial(n)
# дальше всякие действия с переменной f
{% inputdata %}
5
{% endinputdata %}
{% endprogram %}

<p>Если нужно, чтобы функция вернула не одно значение, а два или более, то
для этого функция может вернуть список из двух или нескольких значений:
 
{% noprogram %}
return [a, b]
{% endnoprogram %}
 
<p>Тогда результат вызова функции можно будет использовать во множественном присваивании:
 
{% noprogram %}
n, m = f(a, b)
{% endnoprogram %}

{% endsection %}

{% section "Рекурсия" %}

<div style="padding-left: 20%;">
{% noprogram %}
def short_story():
    print("У попа была собака, он ее любил.")
    print("Она съела кусок мяса, он ее убил,")
    print("В землю закопал и надпись написал:")
    short_story()
{% endnoprogram %}
</div>

   <p>Как мы видели выше, функция может вызывать другую функцию. Но функция также может вызывать и саму себя! 
Рассмотрим это на примере функции вычисления факториала. Хорошо известно, что 0!=1, 1!=1. 
А как вычислить величину n! для большого n? Если бы мы могли вычислить величину (n-1)!,
то тогда мы легко вычислим n!, поскольку n!=n&sdot;(n-1)!. Но как вычислить (n-1)!? Если бы
мы вычислили (n-2)!, то мы сможем вычисли и (n-1)!=(n-1)&sdot;(n-2)!. А как вычислить (n-2)!? 
Если бы... В конце концов, мы дойдем до величины 0!, которая равна 1. Таким образом, для вычисления факториала
мы можем использовать значение факториала для меньшего числа. Это можно сделать и в программе на Питоне:
 
{% program %}
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))        
{% endprogram %}
 
<p>Подобный прием  (вызов функцией самой себя) называется рекурсией, а сама функция называется рекурсивной.
 
   <p>Рекурсивные функции являются мощным механизмом в программировании. К сожалению, они не всегда эффективны. Также часто использование рекурсии приводит к ошибкам. Наиболее распространенная
из таких ошибок&nbsp;<!-- /@w -->&ndash; бесконечная рекурсия, когда цепочка вызовов функций никогда не завершается и продолжается,
пока не кончится свободная память в компьютере. Пример бесконечной рекурсии приведен в эпиграфе к этому разделу. 
Две наиболее распространенные причины для бесконечной рекурсии:
 
     <ol type=1 start=1> 
<li>Неправильное оформление выхода из рекурсии. Например, если мы в программе вычисления факториала
забудем поставить проверку <code>if n == 0</code>, то <code>factorial(0)</code> вызовет <code>factorial(-1)</code>,
тот вызовет <code>factorial(-2)</code> и т. д. 
<li>Рекурсивный вызов с неправильными параметрами. Например, если функция <code>factorial(n)</code> будет
вызывать <code>factorial(n)</code>, то также получиться бесконечная цепочка.
        </ol> 
 
   <p>Поэтому при разработке рекурсивной функции необходимо прежде всего оформлять условия завершения рекурсии
и думать, почему рекурсия когда-либо завершит работу.
 

{% endsection %}